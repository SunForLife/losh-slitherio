\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{epstopdf}

\begin{document}
{\section{Правила игры}}

Наша версия игры вдохновлена браузерной онлайн-игрой Slither.io.

Игра происходит на двумерном прямоугольном ограниченном поле размера $n \times m$. Размер поля заранее не известен и зависит от раунда. Координаты всех объектов являются действительными числами.

На поле может находится произвольное количество кусочков еды. Кусочек еды характеризуется своими координатами $food_x, food_y$ и весом $food_w$.

Кроме того, на поле может находиться несколько змеек. Все змейки всех игроков одновременно находятся на одном поле.

Каждая змейка имеет вес $snake_w$. Кроме того, исходя из веса, для змейки вычисляются следующие величины:

\begin{itemize}
\item Радиус змейки: $snake_r = K_1 * log(K_2 * snake_w + K_3)$
\item Длина змейки: $snake_l = \lceil K_4 * snake_w / snake_r^2 + K_5 \rceil $
\end{itemize}

Каждая змейка имеет скелет: ломаную линию, состоящую ровно из $snake_l - 1$ звеньев и, как следствие, $snake_l + 1$ вершины.

Координаты каждой $i$-ой вершины этой ломаной: $(x_i, y_i)$.

При этом все звенья этой ломаной имеют длину $snake_r$: $(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2 = snake_r^2$.

Площадь, занимаемая змейкой, совпадает с объединением площадей $snake_l + 1$ кругов радиуса $snake_r$, при этом центр каждого круга находится соответствующей вершине ломаной скелета $(x_i, y_i)$. 

На рис.~\ref{ris:image} изображён пример площади, занимаемой змейкой, и её скелет. 

\begin{figure}[h]
\center{\includegraphics[width=0.5\linewidth]{image.eps}}
\caption{Змейка и её скелет}
\label{ris:image}
\end{figure}

Каждая змейка имеет текущее направление движения: это вектор $(x_1 - x_2, y_1 - y_2)$. Змейка движется в этом направлении со своей скоростью $snake_v$.

Независимо от направления движения, змейка всегда видит еду и площади других змеек, находящихся в пределах окружности с радиусом $K_{11} snake_r$ и центром в голове змейки.

Базовая скорость змейки равна $K_6 log(snake_w)$. В случае, если змейка в данный момент ускоряется, её скорость равноускоренно увеличивается до скорости $K_7 log(snake_w)$. Если змейка не ускоряется, её скорость равноускоренно замедляется до базовой скорости.

Кроме того, змейка имеет желаемое направление движения: это заданный пользователем вектор. В случае, если угол между текущим направлением движения и этим вектором больше $K_5$, он будет изменён физикой игры так, чтобы соответствовать указанному ограничению.

Каждая змейка имеет голову: это круг радиуса $snake_r$ с центром в координатах $(x_1, y_1)$.

Как только внутрь головы попадает кусочек еды, вес змейки увеличивается на размер этой еды:

$(x_1 - food_x)^2 + (y_1 - food_y)^2 \le snake_r \rightarrow snake_w := snake_w + food_w$

Как только голова вашей змейки сталкивается с телом другой змейки, ваша змейка погибает.
Если голова вашей змейки сталкивается с головой другой змейки, вы погибаете только если ваша скорость была ниже или равна скорости чужой змейки.

$(x_1 - x'_i)^2 + (y_1 - y'_i)^2 \le (snake_r + snake'_r)^2 \land (i \ne 1 \lor i = 1 \land snake_v \le snake'_v) \rightarrow death$

(В утверждении выше знак $\lor$ обозначает логическое ИЛИ, знак $\land$ -- логическое И).

Таким образом, при столкновении змейки с самой собой смерти не происходит.

Когда змейка погибает, в узлах её ломаной появляются кусочки еды массой $snake_w / snake_l$.
Когда змейка ускоряется, в последнем узле её ломаной раз в $K_8$ единиц длины появляется кусочек еды массой $K_9$, при этом масса змейки уменьшается на это же число: $snake_w := snake_w - K_9$.

Когда змека рождается, она имеет заранее заданный вес $K_12$ и появляется в случайном месте игрового поля, но в достаточной удалённости от других змеек. После смерти змейка сразу перерождается. Перерождение можно отслеживать по смене $snake_{id}$. 

Когда вес змейки становится больше $K_{10}$, змейка может (при желании) разделится на двух змеек массой $K_{10}$ и $snake_w - K_{10}$. Эти змейки управляются одним игроком независимо и могут умереть при столкновении друг с другом.

{\section{Интерфейс взаимодействия}}

Игра происходит по сети. Рекомендуемый язык для написания стратегии -- C++, на этом языке будет предоставлена библиотека взаимодействия с нашим игровым сервером. Желающие разрабатывать на других языках будут вынуждены самостоятельно реализовать подобную библиотеку на своём языке.

Игроку известны следующие константы, не изменяющиеся для него во время игры:
\begin{itemize}
\item $player$: номер игрока;
\item $K_{10}$: размер змейки, позволяющий разделение;
\end{itemize}

Остальные константы $K_i$ не передаются, и могут изменяться от игры к игре.

Игроку периодически предоставляется следующая информация для каждой из активных змеек:
\begin{itemize}
\item $snake_{id}$: номер змейки, число, которое не изменяется за всё время существования змейки и не повторяется у змеек одного игрока.
\item $snake_w$
\item $time$: текущее время на сервере (кол-во секунд, прошедших с сотворения мира. Можно, например, попытаться использовать его для вычисления скорости);
\item поле видимости (в него попадёт и ваша змейка):
\begin{itemize}
\item для каждого видимого кусочка еды: $food_x, food_y, food_w$
\item для каждой змейки, площадь которой попадает в радиус видимости: 
\begin{itemize}
\item $snake_{player}$: номер игрока, управляющего этой змейкой;
\item $snake_{id}$: номер змейки; передаётся только если $snake_{player} совпадает с player$;
\item $snake_r$
\item Для каждой видимой точки скелета змейки: $x_i, y_i$. Точки скелета выдаются в том же порядке, в котором они идут в змейке (то есть сначала голова, если она видна).
\end{itemize}
\item для каждого отрезка границы игрового поля, находящейся в области видимости: координаты концов $x_1, y_1, x_2, y_2$;
\end{itemize}
\end{itemize}

{\section{Библиотека C++}}

Для работы с нашей библиотекой необходимо скачать файл losh-slitherio.hpp и положить его рядом с вашим исходным файлом. В программе будет нужно реализовать функцию play, описанную ниже, и вписать свой логин и пароль.

\begin{verbatim}
#include "losh-slitherio.hpp" // для работы библиотеки
                              // нужно подключить этот include.

struct Configuration
{
	int player;
	double k10;
} configuration; // Глобальная переменная configuration,
                 // содержащая указанные поля.

struct Point {
    double x, y;
};

struct Food {
	Point p;
	double w;
};

struct Snake {
    int player;
    int id;
    double r;
    vector<Point> skeleton;
    bool headVisible; // Является ли skeleton[0] головой змейки
};

struct Field {
    int id;
    double w;
    double time;
    vector<Snake> snakes;
    vector<Food> foods;
    vector<pair<Point, Point>> borders;
};

// Функция, которую необходимо реализовать для работы игры
// Принимает область видимости текущей змейки,
// возвращает координаты точки, куда змейка хочет попасть.
// Кроме того, можно изменить значение переменной boost,
// чтобы змейка начала или перестала ускоряться, и значение 
// переменной split, чтобы змейка разделилась на две.
Point play(const Field& field, bool &boost, bool &split);

// Вместо int main() { ... } нужно написать следующее:
SLITHERIO_RUN("сервер", "логин", "пароль", номер_поля)
\end{verbatim}

Будет опубликован пример бота, работающего с нашей библиотекой.

{\section{Самостоятельная реализация}}

В случае использования отличных от С++ языков, либо при желании попрактироваться в разработке многопоточных и/или сетевых приложений, вы можете общаться с нашим игровым сервером напрямую.

Соединение -- это открытое TCP-соединение клиента игры с сервером игры.

Пакет -- это единица информации, отправляемая либо от клиента к серверу, либо от сервера к клиенту. Пакет строится следующим образом:
0-3 байт: длина содержательной части пакета в сетевом порядке байт. 
Таким образом, если прочитать первые 4 байта в массив беззнаковых целых 8битных чисел $h$, оставшаяся длина пакета будет равна $len := ((h[0] * 256 + h[1]) * 256 + h[2]) * 256 + h[3]$.

Далее идёт len байт -- закодированное с помощью Google FlatBuffers (https://github.com/google/flatbuffers) сообщение типа Package.

Все форматы сообщений находятся на github нашей версии игры: https://github.com/bdolgov/losh-slitherio в папке schema.

Шаблон взаимодействия следующий:
\begin{enumerate}
\item Клиент открывает соединение к серверу;
\item Клиент отправляет пакет Login с указанием своего логина и пароля, номера карты;
\item Сервер отвечает пакетом Welcome с указанием конфигурационной информации, либо отвечает пакетом Error, если информация из пакета Login была неверной;
\item Периодически сервер отправляет пакет Field с указанием текущей ситуации на поле;
\item Клиент может периодически отправлять пакет Direction с указанием изменения направления змейки, включения/отключения ускорения или разделения.
\item Сервер может прислать пакет Exit, обозначающий, что игра закончена. Клиент может отправить пакет Exit, обозначающий, что он хочет выйти из игры.
\end{enumerate}

В случае, если клиент отправляет некорректный с точки зрения логики игры пакет (например, пытается разделить слишком маленькую змейку, изменить направление несуществующей змейки), соответствующая часть пакета игнорируется. В случае, если клиент отправляет некорректный с точки зрения протокола пакет (например, с неправильным типом или не являющийся правильным FlatBuffers-объектом), в ответ приходит сообщение Error с текстовым описанием ошибки. Соединение после прихода пакета Error не закрывается. 

{\section{Тестирование}}

Все материалы, в том числе исходные коды программы, используемой для тестирования, и карты, доступны в открытом доступе по адресу
\texttt{https://github.com/bdolgov/losh-slitherio}.

\end{document}
